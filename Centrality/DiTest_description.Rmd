---
title: "DiTest_descritpive"
output: html_document
date: "2024-05-04"
---

#New line is being added with CRTL+ALT+I

Here's a description of each function, along with their variables, expected outcomes, and expected inputs:

bilatDistance(lo, la):

  Purpose: This function calculates the bilateral distance in kilometers between two locations specified by their longitudes (lo) and latitudes (la).
  Variables:
  radj: A constant value of 6371, representing the radius of the Earth in kilometers.
  la and lo: Input vectors containing latitudes and longitudes in decimal degrees.
  Expected Outcome: A vector of bilateral distances between each pair of locations.
  Expected Input: Two vectors of equal length, containing the latitudes and longitudes of the locations.

convertXY(lat, lon):

  Purpose: This function converts latitude and longitude coordinates to x and y coordinates in a Cartesian coordinate system.
  Variables:
  R: The radius of the Earth in meters (6371000 meters).
  lat and lon: Input vectors containing latitudes and longitudes in decimal degrees.
  Expected Outcome: An object containing two vectors, x and y, representing the Cartesian coordinates.
  Expected Input: Two vectors of equal length, containing the latitudes and longitudes of the locations.
  
calcDi(y, x, fun):

  Purpose: This function calculates a set of Di values based on bilateral distances and a specified function (fun).
  Variables:
  y and x: Input vectors containing latitudes and longitudes in decimal degrees.
  fun: A character string specifying the function to use ("invert" or "expo").
  Expected Outcome: A vector of Di values.
  Expected Input: Two vectors of equal length, containing the latitudes and longitudes of the locations, and a character string specifying the function.

getPercentileGlobalConfidenceBand(KDEValues, esp, maxNumb, numIter, startPercentile, percentileStep, upperOrLower):

  Purpose: This function calculates the global confidence band for a set of KDE (Kernel Density Estimation) values.
  Variables:
  KDEValues: A matrix containing the KDE values for multiple iterations.
  esp: The number of spatial units.
  maxNumb: The maximum number of iterations that should exceed the threshold.
  numIter: The total number of iterations.
  startPercentile: The starting percentile for the confidence band calculation.
  percentileStep: The step size for percentile increments or decrements.
  upperOrLower: A character string indicating whether to calculate the upper or lower bound.
  Expected Outcome: An object containing vectors bound and percentile, representing the calculated bounds and corresponding percentiles.
  Expected Input: A matrix of KDE values, and several parameters specifying the confidence band calculation.

globalConfidenceBand(KDEValues, esp, thresh):

  Purpose: This function calculates the global confidence band for a set of KDE values, including both upper and lower bounds.
  Variables:
  KDEValues: A matrix containing the KDE values for multiple iterations.
  esp: The number of spatial units.
  thresh: The threshold value used to determine the maximum number of iterations.
  Expected Outcome: An object containing vectors lowerBound, upperBound, and KDEValues, representing the lower and upper bounds of the confidence band, and the original KDE values.
  Expected Input: A matrix of KDE values and parameters specifying the confidence band calculation.

localConfidenceBand(KDEValues, esp):

  Purpose: This function calculates the local confidence band for a set of KDE values.
  Variables:
  KDEValues: A matrix containing the KDE values for multiple iterations.
  esp: The number of spatial units.
  Expected Outcome: An object containing vectors lowerBound and upperBound, representing the lower and upper bounds of the local confidence band.
  Expected Input: A matrix of KDE values and the number of spatial units.

globalVaues(kdeObs, kdeBench):

  Purpose: This function calculates global values of dispersion and concentration by comparing the KDE of observed data (kdeObs) to a benchmark (kdeBench).
  Variables:
  kdeObs: An object containing the KDE values and x-coordinates of the observed data.
  kdeBench: An object containing the KDE values and x-coordinates of the benchmark data.
  Expected Outcome: An object containing values for theta (concentration), omega (dispersion), delta (their difference), and myMean (the mean of the benchmark data).
  Expected Input: Two objects representing the KDE and x-coordinates of observed and benchmark data.

```{r}
# Load required packages
library(readxl)
library(sp)
library(raster)


bilatDistance <- function(lo, la){ # gives correctly computed bilateral distancs in km
  radj=6371
  la <- 2 * pi * la/360
  lo <- 2 * pi * lo/360
  coslat <- cos(la)
  sinlat <- sin(la)
  dvect <- sinlat %o% sinlat + (coslat %o% coslat) * cos(-outer(lo,  lo, "-"))
  dvect <- dvect[lower.tri(dvect)]
  dvect <- ifelse(dvect > 1, 1, dvect)
  dvect <- radj * acos(dvect)
  return(dvect)
}
 
convertXY<- function(lat,lon){
  R=6371000
  x = R * (cos(9000-lat)* cos(lon))
  y = R * (cos(9000-lat) *sin(lon))
  ergeb=objects();
  ergeb$x=x
  ergeb$y=y
   
  return (ergeb)
}

calcDi<- function(y,x, fun){
  thresh=1 # min distance 
  dist=bilatDistance(y,x)# calculaution of bilateral distances according to McSpatial
  dist[dist<thresh] <-thresh 
  Di=rep(0,length(y))
  pos=1
  i=1
  for(i in 1:(length(Di)-1)){ # calculate Di vlaues
    upTo=length(Di)-i # length of array
    #print(paste("Von ",pos,"um",upTo, sep=" " ))
    for(z in 1:upTo){ # different possible functions to play with --> use invert
      if(fun=="invert" ){
        val=1/(dist[pos]*(length(Di)-1));
      }
      if(fun=="expo"){
        val=exp(-0.05*dist[pos])
        val=val/(length(Di)-1)
      }
      
      Di[i]=Di[i]+val
      mypos=i+z
      Di[mypos]=Di[mypos]+val
      # print(paste("Updaze bei",i,"und",mypos, sep=" " ))
      #print(pos)
      pos=pos+1
      
    }
    
  }
  return (Di)
}


getPercentileGlobalConfidenceBand <- function (KDEValues,esp, maxNumb,numIter, startPercentile, percentileStep, upperOrLower){
  counter=0
  observedNumb=maxNumb+1
  while(observedNumb>maxNumb){
    bound=vector();
    counter=counter+1
    for(i in 1:esp){
      if(upperOrLower=="lower"){
        percentile=startPercentile-(counter*percentileStep)
      }
      else{
        percentile=startPercentile+(counter*percentileStep)
      } 
      quantiles <- quantile(KDEValues[,i], percentile)  
      bound=append(bound,quantiles[[1]])
    }
    observedNumb=0
    for(i in 1:numIter){# WIe oft wird der Bound getroffen
      iter=KDEValues[i,]
      if(upperOrLower=="lower"){
        if(sum(iter<bound)>=1){ # Bound wurden an mindestens einer Stelle getroffen
          observedNumb=observedNumb+1
        }
      }
      else{
        if(sum(iter>bound)>=1){ # Bound wurden an mindestens einer Stelle getroffen
          observedNumb=observedNumb+1
        }
      }
    }
    print(paste("Percenetik:",percentile, " Treffer: ",observedNumb))
  }
  ergeb=objects();
  ergeb$bound=bound;
  ergeb$percentile=percentile
  return (ergeb)
}

globalConfidenceBand <- function (KDEValues,esp, thresh){
  numIter=length(KDEValues[,1])
  maxNumb=(thresh/100)*numIter
  print(maxNumb)
  
  #Calclulation of lower Bound at 1 % Steps
  lowerBoundCalc=getPercentileGlobalConfidenceBand(KDEValues,esp, maxNumb,numIter, 0.05, 0.01, "lower")
  #Calclulation of lower Bound at 0.1 % Steps
  start=lowerBoundCalc$percentile+0.01 # set last position
  lowerBoundCalc=getPercentileGlobalConfidenceBand(KDEValues,esp, maxNumb,numIter, start, 0.001, "lower")
  
  #Calclulation of upper Bound at 1 % Steps
  upperBoundCalc=getPercentileGlobalConfidenceBand(KDEValues,esp, maxNumb,numIter, 0.95, 0.01, "upper")
  #Calclulation of upper Bound at 0.1 % Steps
  start=upperBoundCalc$percentile-0.01 # set last position
  upperBoundCalc=getPercentileGlobalConfidenceBand(KDEValues,esp, maxNumb,numIter, start, 0.001, "upper")
  
  ergeb=objects(); # ergeb means result in German ;)
  ergeb$lowerBound=lowerBoundCalc$bound
  ergeb$upperBound=upperBoundCalc$bound
  ergeb$KDEValues=KDEValues
  return (ergeb)
}  



# calculate local confidence Bands ( not used in Paper)
localConfidenceBand <- function (KDEValues,esp){
  lowerBound=vector();
  upperBound=vector();
  for(i in 1:esp){
    quantiles <- quantile(KDEValues[,i], c(.05,.95))  
    lowerBound=append(lowerBound,quantiles[[1]])
    upperBound=append(upperBound,quantiles[[2]])
  }
  ergeb=objects();
  ergeb$lowerBound=lowerBound
  ergeb$upperBound=upperBound
  return (ergeb)
}

#####  Global Values  ###################################################################################################

# function is used to calculate global dispersion or concentration 
# needs the calculated Di values of the observes industry and the bechmark
globalValues<- function (kdeObs, kdeBench){
  #calculate the median value of Benchmark
  meanIntegral=0
  i=1
  while (meanIntegral<0.5){
    maxb=max(kdeBench$y[i],kdeBench$y[(i+1)])
    d=abs(kdeBench$y[i]-kdeBench$y[(i+1)])
    c=kdeBench$x[(i+1)]-kdeBench$x[i]
    integral=maxb*c-(0.5*(c*d))
    meanIntegral=meanIntegral+integral
    i=i+1
  }
  myMean=kdeBench$x[i]
  omega=0
  theta=0
  print(myMean)
  for(i in 1:(length(kdeObs$y)-1)){
    
    if(kdeObs$y[i]>kdeBench$y[i] && kdeObs$y[(i+1)]>kdeBench$y[(i+1)]){
      maxbObs=max(kdeObs$y[i],kdeObs$y[(i+1)])
      maxbBench=max(kdeBench$y[i],kdeBench$y[(i+1)])
      dObs=abs(kdeObs$y[i]-kdeObs$y[(i+1)])
      dBench=abs(kdeBench$y[i]-kdeBench$y[(i+1)])
      c=kdeObs$x[(i+1)]-kdeObs$x[i]
      integralObs=maxbObs*c-(0.5*(c*dObs))
      integralBench=maxbBench*c-(0.5*(c*dBench))
      integral=integralObs-integralBench
      if(kdeBench$x[i]< myMean){#Dispersion      
        omega=omega+integral
        #print(paste("Dispersion an der Stelle",kdeObs$x[i],"mit Wert",kdeObs$y[i],"zu",kdeBench$y[i], "ergibt:",integral, sep=" "))
      }
      else{#Concentration
        theta=theta+integral
        #print(paste("Konzentration an der Stelle",kdeObs$x[i],"mit Wert",kdeObs$y[i],"zu",kdeBench$y[i], "ergibt:",integral, sep=" "))
      }
    }
  }
  ergeb=objects();
  ergeb$theta=theta
  ergeb$omega=omega
  ergeb$delta=theta-omega
  ergeb$myMean=myMean
  
  return (ergeb)
}

```
 
#To make the provided code run with your benchmark and industry datasets that have longitude and latitude data points, you need to perform the following steps:


Prepare Your Data:

Make sure your benchmark and industry datasets are in data frames or matrices, with columns named "longitude" and "latitude" (or similar) containing the longitude and latitude values, respectively.

Load the Code:

Copy and paste the provided code into an R script file (e.g., "spatial_analysis.R") or directly into your R console.

Set Up Input Data:

Assign your benchmark and industry datasets to variables in your R environment. For example:
benchmark_data <- your_benchmark_dataset  # Replace with your dataset
industry_data <- your_industry_dataset     # Replace with your dataset

Convert Coordinates (Optional):

If you want to convert the longitude and latitude coordinates to x and y coordinates using the convertXY function, you can do so:
benchmark_xy <- convertXY(benchmark_data$latitude, benchmark_data$longitude)
industry_xy <- convertXY(industry_data$latitude, industry_data$longitude)

Calculate Bilateral Distances:

Use the bilatDistance function to calculate the bilateral distances between locations in your datasets:
benchmark_dist <- bilatDistance(benchmark_data$longitude, benchmark_data$latitude)
industry_dist <- bilatDistance(industry_data$longitude, industry_data$latitude)

Calculate Di Values:

Use the calcDi function to calculate the Di values for your datasets. You can choose the function type ("invert" or "expo") based on your requirements:
benchmark_Di <- calcDi(benchmark_data$latitude, benchmark_data$longitude, fun = "invert")
industry_Di <- calcDi(industry_data$latitude, industry_data$longitude, fun = "invert")

Calculate Global Values:

Use the globalVaues function to calculate global values of dispersion and concentration by comparing the KDE of your industry data to the benchmark data:
global_vals <- globalVaues(kdeObs = industry_Di, kdeBench = benchmark_Di)

Calculate Global Confidence Band (Optional):

If you want to calculate the global confidence band for your KDE values, you can use the globalConfidenceBand function:
global_band <- globalConfidenceBand(KDEValues = industry_Di, esp = <number of spatial units>, thresh = 0.9)

Analyze Results:

After executing the code, you will have various results, including bilateral distances, Di values, global values of dispersion and concentration, and (optionally) global confidence bands. Analyze these results based on your specific research questions or objectives.

#More details for the steps of comparison:

Step 7: Calculate Global Values:

In this step, you use the globalVaues function to calculate global values of dispersion and concentration by comparing the Kernel Density Estimation (KDE) of your industry data to the benchmark data.

Here's how the globalVaues function works:

It takes two input arguments: kdeObs and kdeBench.

kdeObs: This is the KDE of your industry data, represented by the Di values calculated in step 6.
kdeBench: This is the KDE of your benchmark data, also represented by the Di values.
The function first calculates the median value of the benchmark KDE. This median value is used as a reference point for comparing the observed and benchmark data.

Next, the function iterates through the KDE values of both the observed and benchmark data. For each pair of values, it checks if the observed KDE value is greater than the benchmark KDE value.

If the observed KDE value is greater, it calculates the integral of the difference between the observed and benchmark KDE curves for that specific interval.

Depending on whether the current x-coordinate (location) is to the left or right of the median value, it accumulates the integral values into two separate variables: omega and theta.

omega accumulates the integral values when the x-coordinate is to the left of the median, indicating dispersion.
theta accumulates the integral values when the x-coordinate is to the right of the median, indicating concentration.
Finally, the function returns an object with the following values:

theta: The sum of integral values indicating concentration.
omega: The sum of integral values indicating dispersion.
delta: The difference between theta and omega, representing the net concentration or dispersion.
myMean: The median value of the benchmark KDE.
Example usage:

global_vals <- globalVaues(kdeObs = industry_Di, kdeBench = benchmark_Di)
After running this code, you can access the calculated global values:

global_vals$theta
global_vals$omega
global_vals$delta
global_vals$myMean
Step 8: Calculate Global Confidence Band (Optional):

In this optional step, you use the globalConfidenceBand function to calculate the global confidence band for your KDE values. This band provides an estimate of the variability or uncertainty in your KDE estimates.

Here's how the globalConfidenceBand function works:

It takes three input arguments: KDEValues, esp, and thresh.

KDEValues: This is a matrix containing the KDE values for multiple iterations or simulations. Each column represents a separate iteration.
esp: The number of spatial units or regions in your data.
thresh: A threshold value used to determine the maximum number of iterations that should exceed a certain threshold.
The function first calculates the maximum number of iterations (maxNumb) that should exceed the threshold. This is calculated as (thresh/100) * numIter, where numIter is the total number of iterations.

Next, it calls the getPercentileGlobalConfidenceBand function (described in the previous response) to calculate the lower and upper bounds of the global confidence band.

The lower bound is calculated using percentiles starting from 0.05 and decreasing in steps of 0.01 and 0.001.
The upper bound is calculated using percentiles starting from 0.95 and increasing in steps of 0.01 and 0.001.
Finally, the function returns an object with the following values:

lowerBound: The lower bound of the global confidence band.
upperBound: The upper bound of the global confidence band.
KDEValues: The original KDE values used for the calculation.
Example usage:

global_band <- globalConfidenceBand(KDEValues = industry_Di, esp = <number of spatial units>, thresh = 0.9)
After running this code, you can access the calculated global confidence band:

global_band$lowerBound
global_band$upperBound

Remember that step 8 is optional and may not be necessary for all analyses. The global confidence band provides a measure of uncertainty or variability in your KDE estimates, which can be useful for assessing the robustness of your results.


```{r}
# Load required packages
#install.packages("McSpatial")
#install.packages("fields")
library(readxl)
library(ggplot2)
library(gridExtra)
library(MASS)
library(ks)
library(stats) # For Mann-Whitney U test

# Load the test and benchmark datasets
locations_industry <- read_excel("data/locations_hydro_V10.xlsx")
locations_bench <- read_excel("data/amadeus_benchmark_V3.xlsx")

# Extract latitude and longitude values
industry_lat <- locations_industry$Lat
industry_lon <- locations_industry$Lon

bench_lat <- locations_bench$Latitude
bench_lon <- locations_bench$Longitude

benchmark_xy <- convertXY(bench_lat, bench_lon)
industry_xy <- convertXY(industry_lat, industry_lon)

# Calculate Di values for both populations
#library(McSpatial)
#library(fields)

di_industry <- calcDi(industry_xy$x, industry_xy$y, fun = "invert")
di_bench <- calcDi(benchmark_xy$x, benchmark_xy$y, fun = "invert")

# 1. Kolmogorov-Smirnov Test
ks.test(di_industry, di_bench)

# 2. Mann-Whitney U Test
wilcox.test(di_industry, di_bench, alternative = "two.sided")

# 3. Kernel Density Estimation and Comparison
library(stats)

# Kernel density estimation
industry_density <- density(di_industry)
bench_density <- density(di_bench)

# Plot the densities
plot(industry_density, main = "Density of Di Values", xlab = "Di Values", ylab = "Density")
lines(bench_density, lty = 2)
legend("topright", legend = c("Industry", "Benchmark"), lty = c(1, 2), col = c("black", "black"))

# Compare the densities
intersect_points <- industry_density$x[industry_density$y > bench_density$y]
cat("Intersection points:", intersect_points, "\n")

# Calculate kernel density estimates (kde) for observed and benchmark data
kdeObs <- density(di_industry)
kdeBench <- density(di_bench)

# Call the globalValues function with the kdeObs and kdeBench as arguments
globalValuesResult <- globalValues(kdeObs, kdeBench)

# Print the result
print(globalValuesResult)
```

```{r}

```




```{r}
# Calculate the 95th percentile of Di values for the benchmark population
bench_95th_percentile <- quantile(di_bench, 0.70)

# Identify firms in the industry population that exceed the 95th percentile
cluster_cores <- di_industry > bench_95th_percentile

# Count the number of firms in the cluster cores
num_cluster_cores <- sum(cluster_cores)

cat("Number of firms in cluster cores:", num_cluster_cores, "\n")

```
```{r}
# Get the indices of firms in the cluster cores
cluster_indices <- which(cluster_cores)

# Extract longitude and latitude for the cluster-core firms
cluster_lon <- locations_industry$Lon[cluster_indices]
cluster_lat <- locations_industry$Lat[cluster_indices]

# Print the longitude and latitude information
cat("Cluster-core firms' longitude and latitude:\n")
print(cluster_lon)
print(cluster_lat)

# Create a data frame with longitude and latitude information
cluster_data <- data.frame(longitude = cluster_lon, latitude = cluster_lat)

# Write the data frame to a CSV file
write.csv(cluster_data, file = "data/cluster_cores.csv", row.names = FALSE)

cat("CSV file created: cluster_cores.csv\n")
```

