---
title: "DiTest_Local"
output: html_document
date: "2024-05-11"
---


```{r cars}
#Function location
bilatDistance <- function(lo, la){ # gives correctly computed bilateral distancs in km
  radj=6371
  la <- 2 * pi * la/360
  lo <- 2 * pi * lo/360
  coslat <- cos(la)
  sinlat <- sin(la)
  dvect <- sinlat %o% sinlat + (coslat %o% coslat) * cos(-outer(lo,  lo, "-"))
  dvect <- dvect[lower.tri(dvect)]
  dvect <- ifelse(dvect > 1, 1, dvect)
  dvect <- radj * acos(dvect)
  print(dvect)
  return(dvect)
}


bilatDistance_new <- function(lo, la){ 
  radj <- 6371
  la_rad <- 2 * pi * la / 360
  lo_rad <- 2 * pi * lo / 360
  coslat <- cos(la_rad)
  sinlat <- sin(la_rad)
  
  # Calculate the differences in longitudes and convert to radians
  dlon_rad <- outer(lo_rad, lo_rad, "-")
  
  # Compute the Haversine formula
  dvect <- sinlat %o% sinlat + (coslat %o% coslat) * cos(dlon_rad)
  dvect <- dvect[lower.tri(dvect)]
  dvect <- ifelse(dvect > 1, 1, dvect)
  dvect <- radj * acos(dvect)
  print(dvect)
  return(dvect)
}

convertXY <- function(lon, lat) {
  # Radius of the Earth in kilometers
  R <- 6371
  
  # Convert latitude and longitude to Cartesian coordinates
  x <- R * cos(lat * pi / 180) * cos(lon * pi / 180)
  y <- R * cos(lat * pi / 180) * sin(lon * pi / 180)
  
  return(data.frame(x = x, y = y))
}

calcDi<- function(y,x, fun){
  thresh=1 # min distance 
  dist=bilatDistance_new(y,x)# calculaution of bilateral distances according to McSpatial
  dist[dist<thresh] <-thresh 
  Di=rep(0,length(y))
  pos=1
  i=1
  for(i in 1:(length(Di)-1)){ # calculate Di vlaues
    upTo=length(Di)-i # length of array
    #print(paste("Von ",pos,"um",upTo, sep=" " ))
    for(z in 1:upTo){ # different possible functions to play with --> use invert
      if(fun=="invert" ){
        val=1/(dist[pos]*(length(Di)-1));
      }
      if(fun=="expo"){
        val=exp(-0.05*dist[pos])
        val=val/(length(Di)-1)
      }
      
      Di[i]=Di[i]+val
      mypos=i+z
      Di[mypos]=Di[mypos]+val
      # print(paste("Updaze bei",i,"und",mypos, sep=" " ))
      #print(pos)
      pos=pos+1
      
    }
    
  }
  return (Di)
}

#####  Global Values  ###################################################################################################

# function is used to calculate global dispersion or concentration 
# needs the calculated Di values of the observes industry and the benchmark
globalValues<- function (kdeObs, kdeBench, obs_lat, obs_lon, location_name){
  #calculate the median value of Benchmark
  meanIntegral=0
  i=1
  while (meanIntegral<0.5){
    maxb=max(kdeBench$y[i],kdeBench$y[(i+1)])
    d=abs(kdeBench$y[i]-kdeBench$y[(i+1)])
    c=kdeBench$x[(i+1)]-kdeBench$x[i]
    integral=maxb*c-(0.5*(c*d))
    meanIntegral=meanIntegral+integral
    i=i+1
  }
  myMean=kdeBench$x[i]
  omega=0
  theta=0
  print(myMean)
  concentration_lat <- c() # To store latitudes of concentration
  concentration_lon <- c() # To store longitudes of concentration
  concentration_name <- c() # To store names of concentration locations
  for(i in 1:(length(kdeObs$y)-1)){
    
    if(kdeObs$y[i]>kdeBench$y[i] && kdeObs$y[(i+1)]>kdeBench$y[(i+1)]){
      maxbObs=max(kdeObs$y[i],kdeObs$y[(i+1)])
      maxbBench=max(kdeBench$y[i],kdeBench$y[(i+1)])
      dObs=abs(kdeObs$y[i]-kdeObs$y[(i+1)])
      dBench=abs(kdeBench$y[i]-kdeBench$y[(i+1)])
      c=kdeObs$x[(i+1)]-kdeObs$x[i]
      integralObs=maxbObs*c-(0.5*(c*dObs))
      integralBench=maxbBench*c-(0.5*(c*dBench))
      integral=integralObs-integralBench
      if(kdeBench$x[i]< myMean){#Dispersion      
        omega=omega+integral
      }
      else{#Concentration
        theta=theta+integral
        concentration_lat <- c(concentration_lat, obs_lat[i])
        concentration_lon <- c(concentration_lon, obs_lon[i])
        concentration_name <- c(concentration_name, location_name[i])

        print(location_name[i])
      }
    }
  }
  ergeb=objects();
  ergeb$theta=theta
  ergeb$omega=omega
  ergeb$delta=theta-omega
  ergeb$myMean=myMean
  ergeb$concentration_lat <- concentration_lat
  ergeb$concentration_lon <- concentration_lon
  ergeb$location_name <- concentration_name
  
  return (ergeb)
}

# Function to remove the last 3 digits after the decimal point
remove_last_three_digits <- function(x) {
  # Convert the number to a string
  x_str <- as.character(x)
  # Find the position of the decimal point
  decimal_pos <- regexpr("\\.", x_str)[1]
  # Determine the cutoff position (3 digits after the decimal point)
  cutoff_pos <- decimal_pos + 10
  # Remove the characters after the cutoff position
  truncated_str <- substr(x_str, 1, cutoff_pos)
  # Convert back to numeric
  truncated_val <- as.numeric(truncated_str)
  return(truncated_val)
}

```

## Download packages
```{r}
#dependencies

install.packages("readxl")
install.packages("dbmss")
install.packages("dplyr")
install.packages("oce")
install.packages("sp")
install.packages("rgdal")    
install.packages("raster")
install.packages("sp")
install.packages("ggplot2")
install.packages("ggfortify")
install.packages(c("sf", "rnaturalearth", "rnaturalearthdata"))

```
```{r}
#load libraries

library(dplyr)
library("readxl")
library(oce)
library(sp)
library(dbmss)
```


#New code!
```{r}
#loading data

locations_industry <- read_excel("data/locations_hydro_V10.xlsx")
locations_bench <- read_excel("data/amadeus_benchmark_V4.xlsx")

# Add 'PointType' column to locations_industry
locations_industry <- locations_industry %>%
  mutate(PointType = "INDUSTRY")

# Add 'PointType' column to locations_bench
locations_bench <- locations_bench %>%
  mutate(PointType = "BENCH")
```
```{r}
# Extract latitude and longitude values
industry_lat <- locations_industry$Lat
industry_lon <- locations_industry$Lon

bench_lat <- locations_bench$Lat
bench_lon <- locations_bench$Lon
```

```{r}
#Convert to X and Y for later. X is lat and Y is Lon

xy_industry <- convertXY(industry_lon, industry_lat)
xy_bench <- convertXY(bench_lon, bench_lat)
```

```{r}
#Prepare datasets for the next steps - create datasets with pointtype in the df etc.

# Combine the data frames by rows (bind_rows)
combined_df_lonlat <- bind_rows(select(locations_industry, Lat, Lon, PointType),
                                select(locations_bench, Lat, Lon, PointType))

# Rename columns 'Lat' to 'x' and 'Lon' to 'y'
combined_df <- combined_df_lonlat %>%
  rename(x = Lat, y = Lon)

# Print the resulting data frame
print(combined_df)

```

```{r}

xy_industry_df <- data.frame(xy_industry)
xy_bench_df <- data.frame(xy_bench)

# Add 'PointType' column to xy_industry
xy_industry_df <- xy_industry_df %>%
  mutate(PointType = "INDUSTRY")

# Add 'PointType' column to bench
xy_bench_df <- xy_bench_df %>%
  mutate(PointType = "BENCH")

# Combine the data frames by rows (bind_rows)
# Combine the selected columns by rows (bind_rows)
combined_df_xy <- bind_rows(select(xy_bench_df, x, y, PointType),
                          select(xy_industry_df, x, y, PointType))

# Display the combined data frame
print(combined_df_xy)
```
#working with the dbmss library to calculate relative and absolute indexes

#startin with the creation of a wmppp

```{r}
X <- wmppp(data.frame(X = combined_df_xy$x, Y = combined_df_xy$y, PointType = combined_df_xy$PointType))
X
```
#wmppp is created, now the analysis can begin
#startin with k(d) function by D&O:

```{r}
KdE <- KdEnvelope(
  X, 
  r = seq(0, 3000, 10), 
  NumberOfSimulations = 100, 
  ReferenceType = "INDUSTRY", 
  Global = TRUE,
  Original = FALSE,
  
)
p <- autoplot(KdE, main = "")

ggsave(plot = p, filename = "kde_plot.png", device = "png")
```


```{r}
KdE <- KdEnvelope(
  X, 
  r = seq(0, 1000, 10), 
  NumberOfSimulations = 100, 
  ReferenceType = "INDUSTRY", 
  Global = TRUE,
  Original = FALSE,
  
)
p <- autoplot(KdE, main = "")

ggsave(plot = p, filename = "kde_plot_1000.png", device = "png")
```



```{r}
Envelope <- MEnvelope(
  X, 
  r = seq(0, 1300, 10), 
  NumberOfSimulations = 100,
  Alpha = 0.05, 
  ReferenceType = "INDUSTRY",
  NeighborType = "BENCH",
  CaseControl = TRUE,
  SimulationType = "RandomLabeling", 
  Global = TRUE
)
p <- autoplot(Envelope, main = "")

ggsave(plot = p, filename = "M_plot.png", device = "png")
```


#Old Code #####################################################################################################


```{r}
locations_industry <- read_excel("data/locations_hydro_V10.xlsx")
locations_bench <- read_excel("data/amadeus_benchmark_V4.xlsx")

# Extract latitude and longitude values
industry_lat <- locations_industry$Lat
industry_lon <- locations_industry$Lon

bench_lat <- locations_bench$Lat
bench_lon <- locations_bench$Lon

xy_industry <- convertXY(industry_lat, industry_lon)
xy_bench <- convertXY(bench_lat, bench_lon)

# Calculate Di values
di_industry <- calcDi(industry_lon, industry_lat, fun = "invert")
di_bench <- calcDi(bench_lon, bench_lat, fun = "invert")

# Perform statistical tests
ks_test_result <- ks.test(di_industry, di_bench)
print(ks_test_result)

mann_whitney_result <- wilcox.test(di_industry, di_bench, alternative = "two.sided")
print(mann_whitney_result)

# Kernel Density Estimation and Comparison
library(stats)

industry_density <- density(di_industry, n = 500)
bench_density <- density(di_bench, n = 500)

# Set the file name and path for saving the image
file_name <- "density_plot.png"
file_path <- "data/"

# Combine file path and name
file <- paste0(file_path, file_name)

# Start recording the plot as a PNG file
png(file)

# Plot the densities
plot(bench_density, main = "Density of Di Values", xlab = "Di Values", ylab = "Density")
lines(industry_density, lty = 2)
legend("topright", legend = c("Bench", "Industry"), lty = c(1, 2), col = c("black", "black"))

# Stop recording and close the connection
dev.off())

# Calculate global values and concentrations
result <- globalValues(industry_density, bench_density, industry_lat, industry_lon, locations_industry$Name)

print(result)
```
```{r}
di_industry
di_bench
```


```{r}
# Combine the latitudes and longitudes into a data frame
concentration_df <- data.frame(
  Latitude = result$concentration_lat,
  Longitude = result$concentration_lon
)

# Print the concentration data frame
print(concentration_df)

# Write the data frame to a CSV file
write.csv(concentration_df, "concentration_locations.csv", row.names = FALSE)
```

```{r pressure, echo=FALSE}
library("readxl")
library(oce)
library(sp)


locations_industry <- read_excel("data/locations_hydro_V10.xlsx")
locations_bench <- read_excel("data/amadeus_benchmark_V4.xlsx")

# Extract latitude and longitude values
industry_lat <- locations_industry$Lat
industry_lon <- locations_industry$Lon

bench_lat <- locations_bench$Lat
bench_lon <- locations_bench$Lon

# Convert character vectors to numeric
industry_lat <- as.numeric(industry_lat)
industry_lon <- as.numeric(industry_lon)

# Now you can use the convertXY_new function
xy_industry <- convertXY(industry_lon, industry_lat)
xy_bench <- convertXY(locations_bench$Lon, locations_bench$Lat)

```

#going forward with the DiDistance

```{r}
di_industry <- calcDi(locations_industry$Lon, locations_industry$Lat, fun = "invert")
di_bench <- calcDi(locations_bench$Lon, locations_bench$Lat, fun = "invert")

```

```{r}

# 1. Kolmogorov-Smirnov Test
ks_test_result <- ks.test(di_industry, di_bench)

# Print the Kolmogorov-Smirnov test result
print(ks_test_result)

# 2. Mann-Whitney U Test
mann_whitney_result <- wilcox.test(di_industry, di_bench, alternative = "two.sided")

# Print the Mann-Whitney U test result
print(mann_whitney_result)

# 3. Kernel Density Estimation and Comparison
library(stats)

industry_density <- density(di_industry, n = 500)
bench_density <- density(di_bench, n = 500)

# Plot the densities
plot(bench_density, main = "Density of Di Values", xlab = "Di Values", ylab = "Density")
lines(industry_density, lty = 2)
legend("topright", legend = c("Bench", "Industry"), lty = c(1, 2), col = c("black", "black"))


x <- globalValues(industry_density, bench_density)
x

```

```{r}
library(dplyr)


# Function to remove the last 3 digits after the decimal point
remove_last_three_digits <- function(x) {
  # Convert the number to a string
  x_str <- as.character(x)
  # Find the position of the decimal point
  decimal_pos <- regexpr("\\.", x_str)[1]
  # Determine the cutoff position (3 digits after the decimal point)
  cutoff_pos <- decimal_pos + 10
  # Remove the characters after the cutoff position
  truncated_str <- substr(x_str, 1, cutoff_pos)
  # Convert back to numeric
  truncated_val <- as.numeric(truncated_str)
  return(truncated_val)
}

# Assuming 'locations_industry' and 'locations_bench' are your data frames
# Add 'PointType' column to locations_industry
locations_industry <- locations_industry %>%
  mutate(PointType = "INDUSTRY")

# Add 'PointType' column to locations_bench
locations_bench <- locations_bench %>%
  mutate(PointType = "BENCH")

# Combine the data frames by rows (bind_rows)
combined_df_lonlat <- bind_rows(select(locations_industry, Lat, Lon, PointType),
                                select(locations_bench, Lat, Lon, PointType))

# Apply the truncation function to 'Lat' and 'Lon' columns
combined_df_lonlat <- combined_df_lonlat %>%
  mutate(across(c(Lat, Lon), remove_last_three_digits))

# Rename columns 'Lat' to 'x' and 'Lon' to 'y'
combined_df_xy <- combined_df_lonlat %>%
  rename(x = Lat, y = Lon)

# Print the resulting data frame
print(combined_df_xy)

xy_combined <- convertXY(combined_df_xy$y, combined_df_xy$x)
xy_combined <- cbind(xy_combined, PointType = combined_df_xy$PointType)
xy_combined

```

```{r}
library(dplyr)

xy_industry_df <- data.frame(xy_industry)
xy_bench_df <- data.frame(xy_bench)

# Add 'PointType' column to xy_industry
xy_industry_df <- xy_industry_df %>%
  mutate(PointType = "INDUSTRY")

# Add 'PointType' column to bench
xy_bench_df <- xy_bench_df %>%
  mutate(PointType = "BENCH")

# Combine the data frames by rows (bind_rows)
# Combine the selected columns by rows (bind_rows)
combined_df <- bind_rows(select(xy_bench_df, x, y, PointType),
                          select(xy_industry_df, x, y, PointType))

# Display the combined data frame
print(combined_df)
```

```{r}
library(dbmss)
 
X <- wmppp(combined_df_xy)
```


```{r}
KdE <- KdEnvelope(
  X,
  NumberOfSimulations = 100, 
  ReferenceType = "INDUSTRY",
  Global = FALSE
)
autoplot(KdE, ,main = "")
```


```{r}
Envelope <- MEnvelope(
  X, 
  r = seq(0, 30000, 2), 
  NumberOfSimulations = 100,
  Alpha = 0.05, 
  ReferenceType = "INDUSTRY",
  SimulationType = "RandomLabeling", 
  Global = TRUE
)
autoplot(Envelope, main = "", ylim = c(0, 20))
```



```{r}
# Install necessary packages if not already installed

# Load the packages
library(sf)
library(rnaturalearth)
library(rnaturalearthdata)

# Convert your data to an sf object
X_sf <- st_as_sf(locations_industry, coords = c("Lon", "Lat"), crs = 4326)

# Get map data for Europe
europe_map <- ne_countries(scale = "medium", returnclass = "sf", continent = "Europe")

# Create the plot
ggplot(data = europe_map) +
  geom_sf(fill = "lightgray", color = "white") +
  geom_sf(data = X_sf, aes(color = PointType), size = 3) +
  coord_sf(xlim = c(-10, 40), ylim = c(35, 70), expand = FALSE) +  # Zoom in on Europe
  theme_minimal() +
  labs(title = "Spatial Data in Europe", color = "Point Type") +
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.position = "bottom"
  )

```
