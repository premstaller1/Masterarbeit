---
title: "DiTest_Local"
output: html_document
date: "2024-05-11"
---


```{r cars}

bilatDistance <- function(lo, la){ # gives correctly computed bilateral distancs in km
  radj=6371
  la <- 2 * pi * la/360
  lo <- 2 * pi * lo/360
  coslat <- cos(la)
  sinlat <- sin(la)
  dvect <- sinlat %o% sinlat + (coslat %o% coslat) * cos(-outer(lo,  lo, "-"))
  dvect <- dvect[lower.tri(dvect)]
  dvect <- ifelse(dvect > 1, 1, dvect)
  dvect <- radj * acos(dvect)
  return(dvect)
}
 
convertXY<- function(lat,lon){
  R=6371000
  x = R * (cos(9000-lat)* cos(lon))
  y = R * (cos(9000-lat) *sin(lon))
  ergeb=objects();
  ergeb$x=x
  ergeb$y=y
   
  return (ergeb)
}

calcDi<- function(y,x, fun){
  thresh=1 # min distance 
  dist=bilatDistance(y,x)# calculaution of bilateral distances according to McSpatial
  dist[dist<thresh] <-thresh 
  Di=rep(0,length(y))
  pos=1
  i=1
  for(i in 1:(length(Di)-1)){ # calculate Di vlaues
    upTo=length(Di)-i # length of array
    #print(paste("Von ",pos,"um",upTo, sep=" " ))
    for(z in 1:upTo){ # different possible functions to play with --> use invert
      if(fun=="invert" ){
        val=1/(dist[pos]*(length(Di)-1));
      }
      if(fun=="expo"){
        val=exp(-0.05*dist[pos])
        val=val/(length(Di)-1)
      }
      
      Di[i]=Di[i]+val
      mypos=i+z
      Di[mypos]=Di[mypos]+val
      # print(paste("Updaze bei",i,"und",mypos, sep=" " ))
      #print(pos)
      pos=pos+1
      
    }
    
  }
  return (Di)
}


getPercentileGlobalConfidenceBand <- function (KDEValues,esp, maxNumb,numIter, startPercentile, percentileStep, upperOrLower){
  counter=0
  observedNumb=maxNumb+1
  while(observedNumb>maxNumb){
    bound=vector();
    counter=counter+1
    for(i in 1:esp){
      if(upperOrLower=="lower"){
        percentile=startPercentile-(counter*percentileStep)
      }
      else{
        percentile=startPercentile+(counter*percentileStep)
      } 
      quantiles <- quantile(KDEValues[,i], percentile)  
      bound=append(bound,quantiles[[1]])
    }
    observedNumb=0
    for(i in 1:numIter){# WIe oft wird der Bound getroffen
      iter=KDEValues[i,]
      if(upperOrLower=="lower"){
        if(sum(iter<bound)>=1){ # Bound wurden an mindestens einer Stelle getroffen
          observedNumb=observedNumb+1
        }
      }
      else{
        if(sum(iter>bound)>=1){ # Bound wurden an mindestens einer Stelle getroffen
          observedNumb=observedNumb+1
        }
      }
    }
    print(paste("Percenetik:",percentile, " Treffer: ",observedNumb))
  }
  ergeb=objects();
  ergeb$bound=bound;
  ergeb$percentile=percentile
  return (ergeb)
}
globalConfidenceBand <- function (KDEValues,esp, thresh){
  numIter=length(KDEValues[,1])
  maxNumb=(thresh/100)*numIter
  print(maxNumb)
  
  #Calclulation of lower Bound at 1 % Steps
  lowerBoundCalc=getPercentileGlobalConfidenceBand(KDEValues,esp, maxNumb,numIter, 0.05, 0.01, "lower")
  #Calclulation of lower Bound at 0.1 % Steps
  start=lowerBoundCalc$percentile+0.01 # set last position
  lowerBoundCalc=getPercentileGlobalConfidenceBand(KDEValues,esp, maxNumb,numIter, start, 0.001, "lower")
  
  #Calclulation of upper Bound at 1 % Steps
  upperBoundCalc=getPercentileGlobalConfidenceBand(KDEValues,esp, maxNumb,numIter, 0.95, 0.01, "upper")
  #Calclulation of upper Bound at 0.1 % Steps
  start=upperBoundCalc$percentile-0.01 # set last position
  upperBoundCalc=getPercentileGlobalConfidenceBand(KDEValues,esp, maxNumb,numIter, start, 0.001, "upper")
  
  ergeb=objects(); # ergeb means result in German ;)
  ergeb$lowerBound=lowerBoundCalc$bound
  ergeb$upperBound=upperBoundCalc$bound
  ergeb$KDEValues=KDEValues
  return (ergeb)
}  



# calculate local confidence Bands ( not used in Paper)
localConfidenceBand <- function (KDEValues,esp){
  lowerBound=vector();
  upperBound=vector();
  for(i in 1:esp){
    quantiles <- quantile(KDEValues[,i], c(.05,.95))  
    lowerBound=append(lowerBound,quantiles[[1]])
    upperBound=append(upperBound,quantiles[[2]])
  }
  ergeb=objects();
  ergeb$lowerBound=lowerBound
  ergeb$upperBound=upperBound
  return (ergeb)
}

#####  Global Values  ###################################################################################################

# function is used to calculate global dispersion or concentration 
# needs the calculated Di values of the observes industry and the bechmark
globalValues<- function (kdeObs, kdeBench){
  #calculate the median value of Benchmark
  meanIntegral=0
  i=1
  while (meanIntegral<0.5){
    maxb=max(kdeBench$y[i],kdeBench$y[(i+1)])
    d=abs(kdeBench$y[i]-kdeBench$y[(i+1)])
    c=kdeBench$x[(i+1)]-kdeBench$x[i]
    integral=maxb*c-(0.5*(c*d))
    meanIntegral=meanIntegral+integral
    i=i+1
  }
  myMean=kdeBench$x[i]
  omega=0
  theta=0
  print(myMean)
  for(i in 1:(length(kdeObs$y)-1)){
    
    if(kdeObs$y[i]>kdeBench$y[i] && kdeObs$y[(i+1)]>kdeBench$y[(i+1)]){
      maxbObs=max(kdeObs$y[i],kdeObs$y[(i+1)])
      maxbBench=max(kdeBench$y[i],kdeBench$y[(i+1)])
      dObs=abs(kdeObs$y[i]-kdeObs$y[(i+1)])
      dBench=abs(kdeBench$y[i]-kdeBench$y[(i+1)])
      c=kdeObs$x[(i+1)]-kdeObs$x[i]
      integralObs=maxbObs*c-(0.5*(c*dObs))
      integralBench=maxbBench*c-(0.5*(c*dBench))
      integral=integralObs-integralBench
      if(kdeBench$x[i]< myMean){#Dispersion      
        omega=omega+integral
        #print(paste("Dispersion an der Stelle",kdeObs$x[i],"mit Wert",kdeObs$y[i],"zu",kdeBench$y[i], "ergibt:",integral, sep=" "))
      }
      else{#Concentration
        theta=theta+integral
        #print(paste("Konzentration an der Stelle",kdeObs$x[i],"mit Wert",kdeObs$y[i],"zu",kdeBench$y[i], "ergibt:",integral, sep=" "))
      }
    }
  }
  ergeb=objects();
  ergeb$theta=theta
  ergeb$omega=omega
  ergeb$delta=theta-omega
  ergeb$myMean=myMean
  
  return (ergeb)
}

```

## Including Plots
```{r}
#dependencies

install.packages("readxl")
install.packages("dbmss")
install.packages("dplyr")
install.packages("oce")
install.packages("sp")
install.packages("rgdal")    
install.packages("raster")

```


```{r pressure, echo=FALSE}
library("readxl")
library(oce)
library(sp)


locations_industry <- read_excel("data/locations_hydro_V10.xlsx")
#sampled_indices <- sample(nrow(locations_industry), 1000)
#locations_industry <- locations_industry[sampled_indices, ]

locations_bench <- read_excel("data/amadeus_benchmark_V4.xlsx")
#sampled_indices <- sample(nrow(locations_bench), 3000)
#locations_bench <- locations_bench[sampled_indices, ]

# Extract latitude and longitude values
industry_lat <- locations_industry$Lat
industry_lon <- locations_industry$Lon

bench_lat <- locations_bench$Lat
bench_lon <- locations_bench$Lon

xy_industry <- convertXY(industry_lat, industry_lon)
xy_bench <- convertXY(locations_bench$Lat, locations_bench$Lon)

```
#going forward with the DiDistance

```{r}
di_industry <- calcDi(locations_industry$Lon, locations_industry$Lat, fun = "invert")
di_bench <- calcDi(locations_bench$Lon, locations_bench$Lat, fun = "invert")

```



```{r}

# 1. Kolmogorov-Smirnov Test
ks_test_result <- ks.test(di_industry, di_bench)

# Print the Kolmogorov-Smirnov test result
print(ks_test_result)

# 2. Mann-Whitney U Test
mann_whitney_result <- wilcox.test(di_industry, di_bench, alternative = "two.sided")

# Print the Mann-Whitney U test result
print(mann_whitney_result)

# 3. Kernel Density Estimation and Comparison
library(stats)

industry_density <- density(di_industry, n = 500)
bench_density <- density(di_bench, n = 500)

# Plot the densities
plot(bench_density, main = "Density of Di Values", xlab = "Di Values", ylab = "Density")
lines(industry_density, lty = 2)
legend("topright", legend = c("Bench", "Industry"), lty = c(1, 2), col = c("black", "black"))


x <- globalValues(industry_density, bench_density)
x

```


```{r}
# Load required libraries
x <- globalValues(industry_density, bench_density)

```





```{r}
library(dplyr)

# Add 'PointType' column to locations_industry
locations_industry <- locations_industry %>%
  mutate(PointType = "INDUSTRY")

# Add 'PointType' column to bench
locations_bench <- locations_bench %>%
  mutate(PointType = "BENCH")

# Combine the data frames by rows (bind_rows)
# Combine the selected columns by rows (bind_rows)
combined_df_lonlat <- bind_rows(select(locations_industry, Lat, Lon, PointType),
                          select(locations_bench, Lat, Lon, PointType))
# Assuming 'combined_df_lonlat' has columns 'Lat', 'Lon', and 'PointType'
combined_df_xy <- combined_df_lonlat %>%
  rename(x = Lat,
         y = Lon)

combined_df_xy

```

```{r}
xy_industry_df <- data.frame(xy_industry)
xy_bench_df <- data.frame(xy_bench)

# Add 'PointType' column to xy_industry
xy_industry_df <- xy_industry_df %>%
  mutate(PointType = "INDUSTRY")

# Add 'PointType' column to bench
xy_bench_df <- xy_bench_df %>%
  mutate(PointType = "BENCH")

# Combine the data frames by rows (bind_rows)
# Combine the selected columns by rows (bind_rows)
combined_df <- bind_rows(select(xy_bench_df, x, y, PointType),
                          select(xy_industry_df, x, y, PointType))

# Display the combined data frame
print(combined_df)
```

```{r}
library(dbmss)
 
X <- wmppp(combined_df)

KdE <- KdEnvelope(
  X, 
  NumberOfSimulations = 100, 
  ReferenceType = "INDUSTRY", 
  Global = TRUE
)
autoplot(KdE, ,main = "")
```

```{r}
install.packages("ggplot2")
install.packages("ggfortify")
```


```{r}
Envelope <- MEnvelope(
  X, 
  r = seq(0, 30000, 2), 
  NumberOfSimulations = 100,
  Alpha = 0.05, 
  ReferenceType = "INDUSTRY",
  SimulationType = "RandomLabeling", 
  Global = TRUE
)
autoplot(Envelope, main = "", ylim = c(0, 20))
```



```{r}
autoplot(X)
```

```{r}
confidence_bands$lowerBound
```


Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
