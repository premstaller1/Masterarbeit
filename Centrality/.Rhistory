if (kdeObs$y[i] > kdeBench$y[i] && kdeObs$y[i + 1] > kdeBench$y[i + 1]) {
maxbObs <- max(kdeObs$y[i], kdeObs$y[i + 1])
maxbBench <- max(kdeBench$y[i], kdeBench$y[i + 1])
dObs <- abs(kdeObs$y[i] - kdeObs$y[i + 1])
dBench <- abs(kdeBench$y[i] - kdeBench$y[i + 1])
c <- kdeObs$x[i + 1] - kdeObs$x[i]
integralObs <- maxbObs * c - (0.5 * (c * dObs))
integralBench <- maxbBench * c - (0.5 * (c * dBench))
integral <- integralObs - integralBench
if (kdeBench$x[i] < myMean) { # Dispersion
omega <- omega + integral
} else { # Concentration
theta <- theta + integral
# Add company data to the concentratedCompanies list
concentratedCompanies <- append(concentratedCompanies, list(list(name = obsData$name[i], lat = obsData$lat[i], lon = obsData$lon[i])))
}
}
}
ergeb <- list()
ergeb$theta <- theta
ergeb$omega <- omega
ergeb$delta <- theta - omega
ergeb$myMean <- myMean
ergeb$concentratedCompanies <- concentratedCompanies
return(ergeb)
}
result <- globalValues_new(industry_density, bench_density, obsData, benchData)
print(result)
#Function location
bilatDistance <- function(lo, la){ # gives correctly computed bilateral distancs in km
radj=6371
la <- 2 * pi * la/360
lo <- 2 * pi * lo/360
coslat <- cos(la)
sinlat <- sin(la)
dvect <- sinlat %o% sinlat + (coslat %o% coslat) * cos(-outer(lo,  lo, "-"))
dvect <- dvect[lower.tri(dvect)]
dvect <- ifelse(dvect > 1, 1, dvect)
dvect <- radj * acos(dvect)
return(dvect)
}
bilatDistance_new <- function(lo, la){
radj <- 6371
la_rad <- 2 * pi * la / 360
lo_rad <- 2 * pi * lo / 360
coslat <- cos(la_rad)
sinlat <- sin(la_rad)
# Calculate the differences in longitudes and convert to radians
dlon_rad <- outer(lo_rad, lo_rad, "-")
# Compute the Haversine formula
dvect <- sinlat %o% sinlat + (coslat %o% coslat) * cos(dlon_rad)
dvect <- dvect[lower.tri(dvect)]
dvect <- ifelse(dvect > 1, 1, dvect)
dvect <- radj * acos(dvect)
print(dvect)
return(dvect)
}
convertXY <- function(lon, lat) {
# Radius of the Earth in kilometers
R <- 6371
# Convert latitude and longitude to Cartesian coordinates
x <- R * cos(lat * pi / 180) * cos(lon * pi / 180)
y <- R * cos(lat * pi / 180) * sin(lon * pi / 180)
return(data.frame(x = x, y = y))
}
calcDi<- function(y,x, fun){
thresh=1 # min distance
dist=bilatDistance(y,x)# calculaution of bilateral distances according to McSpatial
dist[dist<thresh] <-thresh
Di=rep(0,length(y))
pos=1
i=1
for(i in 1:(length(Di)-1)){ # calculate Di vlaues
upTo=length(Di)-i # length of array
#print(paste("Von ",pos,"um",upTo, sep=" " ))
for(z in 1:upTo){ # different possible functions to play with --> use invert
if(fun=="invert" ){
val=1/(dist[pos]*(length(Di)-1));
}
if(fun=="expo"){
val=exp(-0.05*dist[pos])
val=val/(length(Di)-1)
}
Di[i]=Di[i]+val
mypos=i+z
Di[mypos]=Di[mypos]+val
# print(paste("Updaze bei",i,"und",mypos, sep=" " ))
#print(pos)
pos=pos+1
}
}
return (Di)
}
#####  Global Values  ###################################################################################################
# function is used to calculate global dispersion or concentration
# needs the calculated Di values of the observes industry and the benchmark
globalValues <- function(kdeObs, kdeBench, obsData, benchData) {
# Calculate the median value of Benchmark
meanIntegral <- 0
i <- 1
while (meanIntegral < 0.5 && i < length(kdeBench$x)) {
maxb <- max(kdeBench$y[i], kdeBench$y[i + 1])
d <- abs(kdeBench$y[i] - kdeBench$y[i + 1])
c <- kdeBench$x[i + 1] - kdeBench$x[i]
integral <- maxb * c - (0.5 * (c * d))
meanIntegral <- meanIntegral + integral
i <- i + 1
}
myMean <- kdeBench$x[i]
omega <- 0
theta <- 0
concentratedCompanies <- list()
for (i in 1:(length(kdeObs$y) - 1)) {
if (kdeObs$y[i] > kdeBench$y[i] && kdeObs$y[i + 1] > kdeBench$y[i + 1]) {
maxbObs <- max(kdeObs$y[i], kdeObs$y[i + 1])
maxbBench <- max(kdeBench$y[i], kdeBench$y[i + 1])
dObs <- abs(kdeObs$y[i] - kdeObs$y[i + 1])
dBench <- abs(kdeBench$y[i] - kdeBench$y[i + 1])
c <- kdeObs$x[i + 1] - kdeObs$x[i]
integralObs <- maxbObs * c - (0.5 * (c * dObs))
integralBench <- maxbBench * c - (0.5 * (c * dBench))
integral <- integralObs - integralBench
if (kdeBench$x[i] < myMean) { # Dispersion
omega <- omega + integral
} else { # Concentration
theta <- theta + integral
# Add company data to the concentratedCompanies list
company_info <- list(name = obsData$name[i], lat = obsData$lat[i], lon = obsData$lon[i])
concentratedCompanies <- append(concentratedCompanies, list(company_info))
}
}
}
ergeb <- list()
ergeb$theta <- theta
ergeb$omega <- omega
ergeb$delta <- theta - omega
ergeb$myMean <- myMean
ergeb$concentratedCompanies <- concentratedCompanies
return(ergeb)
}
extractConcentratedCompanies <- function(kdeObs, obsData, myMean) {
concentratedCompanies <- list()
for (i in 1:length(kdeObs$x)) {
if (kdeObs$x[i] > myMean) {
# Add company data to the concentratedCompanies list
company_info <- list(name = obsData$name[i], lat = obsData$lat[i], lon = obsData$lon[i])
concentratedCompanies <- append(concentratedCompanies, list(company_info))
}
}
return(concentratedCompanies)
}
return(concentratedCompanies)
#Function location
bilatDistance <- function(lo, la){ # gives correctly computed bilateral distancs in km
radj=6371
la <- 2 * pi * la/360
lo <- 2 * pi * lo/360
coslat <- cos(la)
sinlat <- sin(la)
dvect <- sinlat %o% sinlat + (coslat %o% coslat) * cos(-outer(lo,  lo, "-"))
dvect <- dvect[lower.tri(dvect)]
dvect <- ifelse(dvect > 1, 1, dvect)
dvect <- radj * acos(dvect)
return(dvect)
}
bilatDistance_new <- function(lo, la){
radj <- 6371
la_rad <- 2 * pi * la / 360
lo_rad <- 2 * pi * lo / 360
coslat <- cos(la_rad)
sinlat <- sin(la_rad)
# Calculate the differences in longitudes and convert to radians
dlon_rad <- outer(lo_rad, lo_rad, "-")
# Compute the Haversine formula
dvect <- sinlat %o% sinlat + (coslat %o% coslat) * cos(dlon_rad)
dvect <- dvect[lower.tri(dvect)]
dvect <- ifelse(dvect > 1, 1, dvect)
dvect <- radj * acos(dvect)
print(dvect)
return(dvect)
}
convertXY <- function(lon, lat) {
# Radius of the Earth in kilometers
R <- 6371
# Convert latitude and longitude to Cartesian coordinates
x <- R * cos(lat * pi / 180) * cos(lon * pi / 180)
y <- R * cos(lat * pi / 180) * sin(lon * pi / 180)
return(data.frame(x = x, y = y))
}
calcDi<- function(y,x, fun){
thresh=1 # min distance
dist=bilatDistance(y,x)# calculaution of bilateral distances according to McSpatial
dist[dist<thresh] <-thresh
Di=rep(0,length(y))
pos=1
i=1
for(i in 1:(length(Di)-1)){ # calculate Di vlaues
upTo=length(Di)-i # length of array
#print(paste("Von ",pos,"um",upTo, sep=" " ))
for(z in 1:upTo){ # different possible functions to play with --> use invert
if(fun=="invert" ){
val=1/(dist[pos]*(length(Di)-1));
}
if(fun=="expo"){
val=exp(-0.05*dist[pos])
val=val/(length(Di)-1)
}
Di[i]=Di[i]+val
mypos=i+z
Di[mypos]=Di[mypos]+val
# print(paste("Updaze bei",i,"und",mypos, sep=" " ))
#print(pos)
pos=pos+1
}
}
return (Di)
}
#####  Global Values  ###################################################################################################
# function is used to calculate global dispersion or concentration
# needs the calculated Di values of the observes industry and the benchmark
globalVaues<- function (kdeObs, kdeBench){
#calculate the median value of Benchmark
meanIntegral=0
i=1
while (meanIntegral<0.5){
maxb=max(kdeBench$y[i],kdeBench$y[(i+1)])
d=abs(kdeBench$y[i]-kdeBench$y[(i+1)])
c=kdeBench$x[(i+1)]-kdeBench$x[i]
integral=maxb*c-(0.5*(c*d))
meanIntegral=meanIntegral+integral
i=i+1
}
myMean=kdeBench$x[i]
omega=0
theta=0
print(myMean)
for(i in 1:(length(kdeObs$y)-1)){
if(kdeObs$y[i]>kdeBench$y[i] && kdeObs$y[(i+1)]>kdeBench$y[(i+1)]){
maxbObs=max(kdeObs$y[i],kdeObs$y[(i+1)])
maxbBench=max(kdeBench$y[i],kdeBench$y[(i+1)])
dObs=abs(kdeObs$y[i]-kdeObs$y[(i+1)])
dBench=abs(kdeBench$y[i]-kdeBench$y[(i+1)])
c=kdeObs$x[(i+1)]-kdeObs$x[i]
integralObs=maxbObs*c-(0.5*(c*dObs))
integralBench=maxbBench*c-(0.5*(c*dBench))
integral=integralObs-integralBench
if(kdeBench$x[i]< myMean){#Dispersion
omega=omega+integral
}
else{#Concentration
theta=theta+integral
}
}
}
ergeb=objects();
ergeb$theta=theta
ergeb$omega=omega
ergeb$delta=theta-omega
ergeb$myMean=myMean
return (ergeb)
}
extractConcentratedCompanies <- function(kdeObs, obsData, myMean) {
concentratedCompanies <- list()
for (i in 1:length(kdeObs$x)) {
if (kdeObs$x[i] > myMean) {
# Add company data to the concentratedCompanies list
company_info <- list(name = obsData$name[i], lat = obsData$lat[i], lon = obsData$lon[i])
concentratedCompanies <- append(concentratedCompanies, list(company_info))
}
}
return(concentratedCompanies)
}
# Function to remove the last 3 digits after the decimal point
remove_last_three_digits <- function(x) {
# Convert the number to a string
x_str <- as.character(x)
# Find the position of the decimal point
decimal_pos <- regexpr("\\.", x_str)[1]
# Determine the cutoff position (3 digits after the decimal point)
cutoff_pos <- decimal_pos + 10
# Remove the characters after the cutoff position
truncated_str <- substr(x_str, 1, cutoff_pos)
# Convert back to numeric
truncated_val <- as.numeric(truncated_str)
return(truncated_val)
}
result <- globalValues_new(industry_density, bench_density)
# Calculate global values and concentrations
result <- globalValues(industry_density, bench_density)
#Function location
bilatDistance <- function(lo, la){ # gives correctly computed bilateral distancs in km
radj=6371
la <- 2 * pi * la/360
lo <- 2 * pi * lo/360
coslat <- cos(la)
sinlat <- sin(la)
dvect <- sinlat %o% sinlat + (coslat %o% coslat) * cos(-outer(lo,  lo, "-"))
dvect <- dvect[lower.tri(dvect)]
dvect <- ifelse(dvect > 1, 1, dvect)
dvect <- radj * acos(dvect)
return(dvect)
}
bilatDistance_new <- function(lo, la){
radj <- 6371
la_rad <- 2 * pi * la / 360
lo_rad <- 2 * pi * lo / 360
coslat <- cos(la_rad)
sinlat <- sin(la_rad)
# Calculate the differences in longitudes and convert to radians
dlon_rad <- outer(lo_rad, lo_rad, "-")
# Compute the Haversine formula
dvect <- sinlat %o% sinlat + (coslat %o% coslat) * cos(dlon_rad)
dvect <- dvect[lower.tri(dvect)]
dvect <- ifelse(dvect > 1, 1, dvect)
dvect <- radj * acos(dvect)
print(dvect)
return(dvect)
}
convertXY <- function(lon, lat) {
# Radius of the Earth in kilometers
R <- 6371
# Convert latitude and longitude to Cartesian coordinates
x <- R * cos(lat * pi / 180) * cos(lon * pi / 180)
y <- R * cos(lat * pi / 180) * sin(lon * pi / 180)
return(data.frame(x = x, y = y))
}
calcDi<- function(y,x, fun){
thresh=1 # min distance
dist=bilatDistance(y,x)# calculaution of bilateral distances according to McSpatial
dist[dist<thresh] <-thresh
Di=rep(0,length(y))
pos=1
i=1
for(i in 1:(length(Di)-1)){ # calculate Di vlaues
upTo=length(Di)-i # length of array
#print(paste("Von ",pos,"um",upTo, sep=" " ))
for(z in 1:upTo){ # different possible functions to play with --> use invert
if(fun=="invert" ){
val=1/(dist[pos]*(length(Di)-1));
}
if(fun=="expo"){
val=exp(-0.05*dist[pos])
val=val/(length(Di)-1)
}
Di[i]=Di[i]+val
mypos=i+z
Di[mypos]=Di[mypos]+val
# print(paste("Updaze bei",i,"und",mypos, sep=" " ))
#print(pos)
pos=pos+1
}
}
return (Di)
}
#####  Global Values  ###################################################################################################
# function is used to calculate global dispersion or concentration
# needs the calculated Di values of the observes industry and the benchmark
globalValues<- function (kdeObs, kdeBench){
#calculate the median value of Benchmark
meanIntegral=0
i=1
while (meanIntegral<0.5){
maxb=max(kdeBench$y[i],kdeBench$y[(i+1)])
d=abs(kdeBench$y[i]-kdeBench$y[(i+1)])
c=kdeBench$x[(i+1)]-kdeBench$x[i]
integral=maxb*c-(0.5*(c*d))
meanIntegral=meanIntegral+integral
i=i+1
}
myMean=kdeBench$x[i]
omega=0
theta=0
print(myMean)
for(i in 1:(length(kdeObs$y)-1)){
if(kdeObs$y[i]>kdeBench$y[i] && kdeObs$y[(i+1)]>kdeBench$y[(i+1)]){
maxbObs=max(kdeObs$y[i],kdeObs$y[(i+1)])
maxbBench=max(kdeBench$y[i],kdeBench$y[(i+1)])
dObs=abs(kdeObs$y[i]-kdeObs$y[(i+1)])
dBench=abs(kdeBench$y[i]-kdeBench$y[(i+1)])
c=kdeObs$x[(i+1)]-kdeObs$x[i]
integralObs=maxbObs*c-(0.5*(c*dObs))
integralBench=maxbBench*c-(0.5*(c*dBench))
integral=integralObs-integralBench
if(kdeBench$x[i]< myMean){#Dispersion
omega=omega+integral
}
else{#Concentration
theta=theta+integral
}
}
}
ergeb=objects();
ergeb$theta=theta
ergeb$omega=omega
ergeb$delta=theta-omega
ergeb$myMean=myMean
return (ergeb)
}
extractConcentratedCompanies <- function(kdeObs, obsData, myMean) {
concentratedCompanies <- list()
for (i in 1:length(kdeObs$x)) {
if (kdeObs$x[i] > myMean) {
# Add company data to the concentratedCompanies list
company_info <- list(name = obsData$name[i], lat = obsData$lat[i], lon = obsData$lon[i])
concentratedCompanies <- append(concentratedCompanies, list(company_info))
}
}
return(concentratedCompanies)
}
# Function to remove the last 3 digits after the decimal point
remove_last_three_digits <- function(x) {
# Convert the number to a string
x_str <- as.character(x)
# Find the position of the decimal point
decimal_pos <- regexpr("\\.", x_str)[1]
# Determine the cutoff position (3 digits after the decimal point)
cutoff_pos <- decimal_pos + 10
# Remove the characters after the cutoff position
truncated_str <- substr(x_str, 1, cutoff_pos)
# Convert back to numeric
truncated_val <- as.numeric(truncated_str)
return(truncated_val)
}
result <- globalValues(industry_density, bench_density)
extractConcentratedCompanies(industry_density, obsData, results$myMean)
# Calculate global values and concentrations
result <- globalValues(industry_density, bench_density)
extractConcentratedCompanies(industry_density, obsData, ergeb$myMean)
View(globalValues)
extractConcentratedCompanies(industry_density, obsData, result$myMean)
x <- extractConcentratedCompanies(industry_density, obsData, result$myMean)
View(x)
View(KdE)
View(industry_density)
View(industry_density)
View(industry_density)
# Detect firms in the first quartile of Di values
first_quartile_threshold <- quantile(di_industry, 0.25)
firms_in_first_quartile <- locations_industry[di_industry <= first_quartile_threshold, ]
# Detect firms above the 95th percentile of benchmark distribution
percentile_95_bench <- quantile(di_bench, 0.95)
firms_above_95_percentile <- locations_industry[di_industry > percentile_95_bench, ]
# Print the firms detected
print("Firms in the first quartile of Di values:")
print(firms_in_first_quartile)
print("Firms above the 95th percentile of benchmark Di values:")
print(firms_above_95_percentile)
# Plot the KDEs with highlighted firms
ggplot() +
geom_line(data = as.data.frame(industry_density), aes(x = x, y = y), color = "blue", linetype = "dashed") +
geom_line(data = as.data.frame(bench_density), aes(x = x, y = y), color = "red") +
labs(title = "Density of Di Values", x = "Di Values", y = "Density") +
theme_minimal() +
geom_vline(xintercept = first_quartile_threshold, color = "green", linetype = "dotted", size = 1) +
geom_vline(xintercept = percentile_95_bench, color = "purple", linetype = "dotted", size = 1) +
annotate("text", x = first_quartile_threshold, y = max(industry_density$y), label = "1st Quartile", vjust = -1, color = "green") +
annotate("text", x = percentile_95_bench, y = max(industry_density$y), label = "95th Percentile", vjust = -1, color = "purple") +
ggsave("density_plot_with_thresholds.png")
library(ggplot2)
# Detect firms in the first quartile of Di values
first_quartile_threshold <- quantile(di_industry, 0.25)
firms_in_first_quartile <- locations_industry[di_industry <= first_quartile_threshold, ]
# Detect firms above the 95th percentile of benchmark distribution
percentile_95_bench <- quantile(di_bench, 0.95)
firms_above_95_percentile <- locations_industry[di_industry > percentile_95_bench, ]
# Print the firms detected
print("Firms in the first quartile of Di values:")
print(firms_in_first_quartile)
print("Firms above the 95th percentile of benchmark Di values:")
print(firms_above_95_percentile)
# Plot the KDEs with highlighted firms
ggplot() +
geom_line(data = as.data.frame(industry_density), aes(x = x, y = y), color = "blue", linetype = "dashed") +
geom_line(data = as.data.frame(bench_density), aes(x = x, y = y), color = "red") +
labs(title = "Density of Di Values", x = "Di Values", y = "Density") +
theme_minimal() +
geom_vline(xintercept = first_quartile_threshold, color = "green", linetype = "dotted", size = 1) +
geom_vline(xintercept = percentile_95_bench, color = "purple", linetype = "dotted", size = 1) +
annotate("text", x = first_quartile_threshold, y = max(industry_density$y), label = "1st Quartile", vjust = -1, color = "green") +
annotate("text", x = percentile_95_bench, y = max(industry_density$y), label = "95th Percentile", vjust = -1, color = "purple") +
ggsave("density_plot_with_thresholds.png")
# Detect firms in the first quartile of Di values
first_quartile_threshold <- quantile(di_industry, 0.25)
firms_in_first_quartile <- locations_industry[di_industry <= first_quartile_threshold, ]
# Detect firms above the 95th percentile of benchmark distribution
percentile_95_bench <- quantile(di_bench, 0.95)
firms_above_95_percentile <- locations_industry[di_industry > percentile_95_bench, ]
# Print the firms detected
print("Firms in the first quartile of Di values:")
print(firms_in_first_quartile)
print("Firms above the 95th percentile of benchmark Di values:")
print(firms_above_95_percentile)
# Detect firms in the first quartile of Di values
first_quartile_threshold <- quantile(di_industry, 0.25)
firms_in_first_quartile <- locations_industry[di_industry <= first_quartile_threshold, ]
# Save firms in the first quartile to CSV
write.csv(firms_in_first_quartile, file = "firms_in_first_quartile.csv", row.names = FALSE)
# Detect firms above the 95th percentile of benchmark distribution
percentile_95_bench <- quantile(di_bench, 0.95)
firms_above_95_percentile <- locations_industry[di_industry > percentile_95_bench, ]
# Save firms above the 95th percentile to CSV
write.csv(firms_above_95_percentile, file = "firms_above_95_percentile.csv", row.names = FALSE)
# Detect firms in the first quartile of Di values
first_quartile_threshold <- quantile(di_industry, 0.90)
firms_in_first_quartile <- locations_industry[di_industry <= first_quartile_threshold, ]
# Save firms in the first quartile to CSV
write.csv(firms_in_first_quartile, file = "firms_in_first_quartile.csv", row.names = FALSE)
# Detect firms above the 95th percentile of benchmark distribution
percentile_95_bench <- quantile(di_bench, 0.95)
firms_above_95_percentile <- locations_industry[di_industry > percentile_95_bench, ]
# Save firms above the 95th percentile to CSV
write.csv(firms_above_95_percentile, file = "firms_above_95_percentile.csv", row.names = FALSE)
