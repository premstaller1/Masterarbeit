ergeb=objects();
ergeb$theta=theta
ergeb$omega=omega
ergeb$delta=theta-omega
ergeb$myMean=myMean
ergeb$concentration_locations <- concentration_locations
return (ergeb)
}
locations_industry <- read_excel("data/locations_hydro_V10.xlsx")
locations_bench <- read_excel("data/amadeus_benchmark_V4.xlsx")
# Extract latitude and longitude values
industry_lat <- locations_industry$Lat
industry_lon <- locations_industry$Lon
bench_lat <- locations_bench$Lat
bench_lon <- locations_bench$Lon
xy_industry <- convertXY(industry_lat, industry_lon)
xy_bench <- convertXY(bench_lat, bench_lon)
# Calculate Di values
di_industry <- calcDi(industry_lon, industry_lat, fun = "invert")
di_bench <- calcDi(bench_lon, bench_lat, fun = "invert")
# Perform statistical tests
ks_test_result <- ks.test(di_industry, di_bench)
print(ks_test_result)
mann_whitney_result <- wilcox.test(di_industry, di_bench, alternative = "two.sided")
print(mann_whitney_result)
# Kernel Density Estimation and Comparison
library(stats)
industry_density <- density(di_industry, n = 500)
bench_density <- density(di_bench, n = 500)
# Plot the densities
plot(bench_density, main = "Density of Di Values", xlab = "Di Values", ylab = "Density")
lines(industry_density, lty = 2)
legend("topright", legend = c("Bench", "Industry"), lty = c(1, 2), col = c("black", "black"))
# Calculate global values and concentrations
result <- globalValues(industry_density, bench_density, industry_lat, industry_lon)
# Print the list of concentration locations
print(result$concentration_locations)
# Convert the list of concentration locations to a data frame
concentration_df <- do.call(rbind, lapply(result$concentration_locations, as.data.frame))
concentration_df <- as.data.frame(concentration_df)
# Write the data frame to a CSV file
write.csv(concentration_df, "concentration_locations.csv", row.names = FALSE)
View(concentration_df)
# Combine the latitudes and longitudes into a data frame
concentration_df <- data.frame(
Latitude = result$concentration_lat,
Longitude = result$concentration_lon
)
# Print the concentration data frame
print(concentration_df)
# Write the data frame to a CSV file
write.csv(concentration_df, "concentration_locations.csv", row.names = FALSE)
bilatDistance <- function(lo, la){ # gives correctly computed bilateral distancs in km
radj=6371
la <- 2 * pi * la/360
lo <- 2 * pi * lo/360
coslat <- cos(la)
sinlat <- sin(la)
dvect <- sinlat %o% sinlat + (coslat %o% coslat) * cos(-outer(lo,  lo, "-"))
dvect <- dvect[lower.tri(dvect)]
dvect <- ifelse(dvect > 1, 1, dvect)
dvect <- radj * acos(dvect)
return(dvect)
}
convertXY<- function(lat,lon){
R=6371000
x = R * (cos(90-lat)* cos(lon))
y = R * (cos(90-lat) *sin(lon))
ergeb=objects();
ergeb$x=x
ergeb$y=y
return (ergeb)
}
calcDi<- function(y,x, fun){
thresh=1 # min distance
dist=bilatDistance(y,x)# calculaution of bilateral distances according to McSpatial
dist[dist<thresh] <-thresh
Di=rep(0,length(y))
pos=1
i=1
for(i in 1:(length(Di)-1)){ # calculate Di vlaues
upTo=length(Di)-i # length of array
#print(paste("Von ",pos,"um",upTo, sep=" " ))
for(z in 1:upTo){ # different possible functions to play with --> use invert
if(fun=="invert" ){
val=1/(dist[pos]*(length(Di)-1));
}
if(fun=="expo"){
val=exp(-0.05*dist[pos])
val=val/(length(Di)-1)
}
Di[i]=Di[i]+val
mypos=i+z
Di[mypos]=Di[mypos]+val
# print(paste("Updaze bei",i,"und",mypos, sep=" " ))
#print(pos)
pos=pos+1
}
}
return (Di)
}
getPercentileGlobalConfidenceBand <- function (KDEValues,esp, maxNumb,numIter, startPercentile, percentileStep, upperOrLower){
counter=0
observedNumb=maxNumb+1
while(observedNumb>maxNumb){
bound=vector();
counter=counter+1
for(i in 1:esp){
if(upperOrLower=="lower"){
percentile=startPercentile-(counter*percentileStep)
}
else{
percentile=startPercentile+(counter*percentileStep)
}
quantiles <- quantile(KDEValues[,i], percentile)
bound=append(bound,quantiles[[1]])
}
observedNumb=0
for(i in 1:numIter){# WIe oft wird der Bound getroffen
iter=KDEValues[i,]
if(upperOrLower=="lower"){
if(sum(iter<bound)>=1){ # Bound wurden an mindestens einer Stelle getroffen
observedNumb=observedNumb+1
}
}
else{
if(sum(iter>bound)>=1){ # Bound wurden an mindestens einer Stelle getroffen
observedNumb=observedNumb+1
}
}
}
print(paste("Percenetik:",percentile, " Treffer: ",observedNumb))
}
ergeb=objects();
ergeb$bound=bound;
ergeb$percentile=percentile
return (ergeb)
}
globalConfidenceBand <- function (KDEValues,esp, thresh){
numIter=length(KDEValues[,1])
maxNumb=(thresh/100)*numIter
print(maxNumb)
#Calclulation of lower Bound at 1 % Steps
lowerBoundCalc=getPercentileGlobalConfidenceBand(KDEValues,esp, maxNumb,numIter, 0.05, 0.01, "lower")
#Calclulation of lower Bound at 0.1 % Steps
start=lowerBoundCalc$percentile+0.01 # set last position
lowerBoundCalc=getPercentileGlobalConfidenceBand(KDEValues,esp, maxNumb,numIter, start, 0.001, "lower")
#Calclulation of upper Bound at 1 % Steps
upperBoundCalc=getPercentileGlobalConfidenceBand(KDEValues,esp, maxNumb,numIter, 0.95, 0.01, "upper")
#Calclulation of upper Bound at 0.1 % Steps
start=upperBoundCalc$percentile-0.01 # set last position
upperBoundCalc=getPercentileGlobalConfidenceBand(KDEValues,esp, maxNumb,numIter, start, 0.001, "upper")
ergeb=objects(); # ergeb means result in German ;)
ergeb$lowerBound=lowerBoundCalc$bound
ergeb$upperBound=upperBoundCalc$bound
ergeb$KDEValues=KDEValues
return (ergeb)
}
# calculate local confidence Bands ( not used in Paper)
localConfidenceBand <- function (KDEValues,esp){
lowerBound=vector();
upperBound=vector();
for(i in 1:esp){
quantiles <- quantile(KDEValues[,i], c(.05,.95))
lowerBound=append(lowerBound,quantiles[[1]])
upperBound=append(upperBound,quantiles[[2]])
}
ergeb=objects();
ergeb$lowerBound=lowerBound
ergeb$upperBound=upperBound
return (ergeb)
}
#####  Global Values  ###################################################################################################
# function is used to calculate global dispersion or concentration
# needs the calculated Di values of the observes industry and the bechmark
globalValues<- function (kdeObs, kdeBench, obs_lat, obs_lon){
#calculate the median value of Benchmark
meanIntegral=0
i=1
while (meanIntegral<0.5){
maxb=max(kdeBench$y[i],kdeBench$y[(i+1)])
d=abs(kdeBench$y[i]-kdeBench$y[(i+1)])
c=kdeBench$x[(i+1)]-kdeBench$x[i]
integral=maxb*c-(0.5*(c*d))
meanIntegral=meanIntegral+integral
i=i+1
}
myMean=kdeBench$x[i]
omega=0
theta=0
print(myMean)
concentration_lat <- c() # To store latitudes of concentration
concentration_lon <- c() # To store longitudes of concentration
for(i in 1:(length(kdeObs$y)-1)){
if(kdeObs$y[i]>kdeBench$y[i] && kdeObs$y[(i+1)]>kdeBench$y[(i+1)]){
maxbObs=max(kdeObs$y[i],kdeObs$y[(i+1)])
maxbBench=max(kdeBench$y[i],kdeBench$y[(i+1)])
dObs=abs(kdeObs$y[i]-kdeObs$y[(i+1)])
dBench=abs(kdeBench$y[i]-kdeBench$y[(i+1)])
c=kdeObs$x[(i+1)]-kdeObs$x[i]
integralObs=maxbObs*c-(0.5*(c*dObs))
integralBench=maxbBench*c-(0.5*(c*dBench))
integral=integralObs-integralBench
if(kdeBench$x[i]< myMean){#Dispersion
omega=omega+integral
print(paste("Dispersion an der Stelle",kdeObs$x[i],"mit Wert",kdeObs$y[i],"zu",kdeBench$y[i], "ergibt:",integral, sep=" "))
}
else{#Concentration
theta=theta+integral
concentration_lat <- c(concentration_lat, obs_lat[i])
concentration_lon <- c(concentration_lon, obs_lon[i])
print(paste("Konzentration an der Stelle",kdeObs$x[i],"mit Wert",kdeObs$y[i],"zu",kdeBench$y[i], "ergibt:",integral, sep=" "))
}
}
}
ergeb=objects();
ergeb$theta=theta
ergeb$omega=omega
ergeb$delta=theta-omega
ergeb$myMean=myMean
ergeb$concentration_locations <- concentration_locations
return (ergeb)
}
result <- globalValues(industry_density, bench_density, industry_lat, industry_lon)
bilatDistance <- function(lo, la){ # gives correctly computed bilateral distancs in km
radj=6371
la <- 2 * pi * la/360
lo <- 2 * pi * lo/360
coslat <- cos(la)
sinlat <- sin(la)
dvect <- sinlat %o% sinlat + (coslat %o% coslat) * cos(-outer(lo,  lo, "-"))
dvect <- dvect[lower.tri(dvect)]
dvect <- ifelse(dvect > 1, 1, dvect)
dvect <- radj * acos(dvect)
return(dvect)
}
convertXY<- function(lat,lon){
R=6371000
x = R * (cos(90-lat)* cos(lon))
y = R * (cos(90-lat) *sin(lon))
ergeb=objects();
ergeb$x=x
ergeb$y=y
return (ergeb)
}
calcDi<- function(y,x, fun){
thresh=1 # min distance
dist=bilatDistance(y,x)# calculaution of bilateral distances according to McSpatial
dist[dist<thresh] <-thresh
Di=rep(0,length(y))
pos=1
i=1
for(i in 1:(length(Di)-1)){ # calculate Di vlaues
upTo=length(Di)-i # length of array
#print(paste("Von ",pos,"um",upTo, sep=" " ))
for(z in 1:upTo){ # different possible functions to play with --> use invert
if(fun=="invert" ){
val=1/(dist[pos]*(length(Di)-1));
}
if(fun=="expo"){
val=exp(-0.05*dist[pos])
val=val/(length(Di)-1)
}
Di[i]=Di[i]+val
mypos=i+z
Di[mypos]=Di[mypos]+val
# print(paste("Updaze bei",i,"und",mypos, sep=" " ))
#print(pos)
pos=pos+1
}
}
return (Di)
}
getPercentileGlobalConfidenceBand <- function (KDEValues,esp, maxNumb,numIter, startPercentile, percentileStep, upperOrLower){
counter=0
observedNumb=maxNumb+1
while(observedNumb>maxNumb){
bound=vector();
counter=counter+1
for(i in 1:esp){
if(upperOrLower=="lower"){
percentile=startPercentile-(counter*percentileStep)
}
else{
percentile=startPercentile+(counter*percentileStep)
}
quantiles <- quantile(KDEValues[,i], percentile)
bound=append(bound,quantiles[[1]])
}
observedNumb=0
for(i in 1:numIter){# WIe oft wird der Bound getroffen
iter=KDEValues[i,]
if(upperOrLower=="lower"){
if(sum(iter<bound)>=1){ # Bound wurden an mindestens einer Stelle getroffen
observedNumb=observedNumb+1
}
}
else{
if(sum(iter>bound)>=1){ # Bound wurden an mindestens einer Stelle getroffen
observedNumb=observedNumb+1
}
}
}
print(paste("Percenetik:",percentile, " Treffer: ",observedNumb))
}
ergeb=objects();
ergeb$bound=bound;
ergeb$percentile=percentile
return (ergeb)
}
globalConfidenceBand <- function (KDEValues,esp, thresh){
numIter=length(KDEValues[,1])
maxNumb=(thresh/100)*numIter
print(maxNumb)
#Calclulation of lower Bound at 1 % Steps
lowerBoundCalc=getPercentileGlobalConfidenceBand(KDEValues,esp, maxNumb,numIter, 0.05, 0.01, "lower")
#Calclulation of lower Bound at 0.1 % Steps
start=lowerBoundCalc$percentile+0.01 # set last position
lowerBoundCalc=getPercentileGlobalConfidenceBand(KDEValues,esp, maxNumb,numIter, start, 0.001, "lower")
#Calclulation of upper Bound at 1 % Steps
upperBoundCalc=getPercentileGlobalConfidenceBand(KDEValues,esp, maxNumb,numIter, 0.95, 0.01, "upper")
#Calclulation of upper Bound at 0.1 % Steps
start=upperBoundCalc$percentile-0.01 # set last position
upperBoundCalc=getPercentileGlobalConfidenceBand(KDEValues,esp, maxNumb,numIter, start, 0.001, "upper")
ergeb=objects(); # ergeb means result in German ;)
ergeb$lowerBound=lowerBoundCalc$bound
ergeb$upperBound=upperBoundCalc$bound
ergeb$KDEValues=KDEValues
return (ergeb)
}
# calculate local confidence Bands ( not used in Paper)
localConfidenceBand <- function (KDEValues,esp){
lowerBound=vector();
upperBound=vector();
for(i in 1:esp){
quantiles <- quantile(KDEValues[,i], c(.05,.95))
lowerBound=append(lowerBound,quantiles[[1]])
upperBound=append(upperBound,quantiles[[2]])
}
ergeb=objects();
ergeb$lowerBound=lowerBound
ergeb$upperBound=upperBound
return (ergeb)
}
#####  Global Values  ###################################################################################################
# function is used to calculate global dispersion or concentration
# needs the calculated Di values of the observes industry and the bechmark
globalValues<- function (kdeObs, kdeBench, obs_lat, obs_lon){
#calculate the median value of Benchmark
meanIntegral=0
i=1
while (meanIntegral<0.5){
maxb=max(kdeBench$y[i],kdeBench$y[(i+1)])
d=abs(kdeBench$y[i]-kdeBench$y[(i+1)])
c=kdeBench$x[(i+1)]-kdeBench$x[i]
integral=maxb*c-(0.5*(c*d))
meanIntegral=meanIntegral+integral
i=i+1
}
myMean=kdeBench$x[i]
omega=0
theta=0
print(myMean)
concentration_lat <- c() # To store latitudes of concentration
concentration_lon <- c() # To store longitudes of concentration
for(i in 1:(length(kdeObs$y)-1)){
if(kdeObs$y[i]>kdeBench$y[i] && kdeObs$y[(i+1)]>kdeBench$y[(i+1)]){
maxbObs=max(kdeObs$y[i],kdeObs$y[(i+1)])
maxbBench=max(kdeBench$y[i],kdeBench$y[(i+1)])
dObs=abs(kdeObs$y[i]-kdeObs$y[(i+1)])
dBench=abs(kdeBench$y[i]-kdeBench$y[(i+1)])
c=kdeObs$x[(i+1)]-kdeObs$x[i]
integralObs=maxbObs*c-(0.5*(c*dObs))
integralBench=maxbBench*c-(0.5*(c*dBench))
integral=integralObs-integralBench
if(kdeBench$x[i]< myMean){#Dispersion
omega=omega+integral
print(paste("Dispersion an der Stelle",kdeObs$x[i],"mit Wert",kdeObs$y[i],"zu",kdeBench$y[i], "ergibt:",integral, sep=" "))
}
else{#Concentration
theta=theta+integral
concentration_lat <- c(concentration_lat, obs_lat[i])
concentration_lon <- c(concentration_lon, obs_lon[i])
print(paste("Konzentration an der Stelle",kdeObs$x[i],"mit Wert",kdeObs$y[i],"zu",kdeBench$y[i], "ergibt:",integral, sep=" "))
}
}
}
ergeb=objects();
ergeb$theta=theta
ergeb$omega=omega
ergeb$delta=theta-omega
ergeb$myMean=myMean
ergeb$concentration_lat <- concentration_lat
ergeb$concentration_lon <- concentration_lon
return (ergeb)
}
result <- globalValues(industry_density, bench_density, industry_lat, industry_lon)
# Combine the latitudes and longitudes into a data frame
concentration_df <- data.frame(
Latitude = result$concentration_lat,
Longitude = result$concentration_lon
)
# Print the concentration data frame
print(concentration_df)
# Write the data frame to a CSV file
write.csv(concentration_df, "concentration_locations.csv", row.names = FALSE)
View(xy_bench)
library(dplyr)
# Add 'PointType' column to locations_industry
locations_industry <- locations_industry %>%
mutate(PointType = "INDUSTRY")
# Add 'PointType' column to bench
locations_bench <- locations_bench %>%
mutate(PointType = "BENCH")
# Combine the data frames by rows (bind_rows)
# Combine the selected columns by rows (bind_rows)
combined_df_lonlat <- bind_rows(select(locations_industry, Lat, Lon, PointType),
select(locations_bench, Lat, Lon, PointType))
# Assuming 'combined_df_lonlat' has columns 'Lat', 'Lon', and 'PointType'
combined_df_xy <- combined_df_lonlat %>%
rename(x = Lat,
y = Lon)
combined_df_xy
# Function to convert scientific notation to regular decimal notation
convert_sci_to_decimal <- function(value) {
return(format(value, scientific = FALSE))
}
# Convert coordinates to regular decimal notation
combined_df_xy$x <- sapply(df$x, convert_sci_to_decimal)
#dependencies
install.packages("readxl")
install.packages("dbmss")
install.packages("dplyr")
install.packages("oce")
install.packages("sp")
install.packages("rgdal")
install.packages("raster")
library(dplyr)
# Add 'PointType' column to locations_industry
locations_industry <- locations_industry %>%
mutate(PointType = "INDUSTRY")
# Add 'PointType' column to bench
locations_bench <- locations_bench %>%
mutate(PointType = "BENCH")
# Combine the data frames by rows (bind_rows)
# Combine the selected columns by rows (bind_rows)
combined_df_lonlat <- bind_rows(select(locations_industry, Lat, Lon, PointType),
select(locations_bench, Lat, Lon, PointType))
# Assuming 'combined_df_lonlat' has columns 'Lat', 'Lon', and 'PointType'
combined_df_xy <- combined_df_lonlat %>%
rename(x = Lat,
y = Lon)
combined_df_xy
# Function to convert scientific notation to regular decimal notation
convert_sci_to_decimal <- function(value) {
return(format(value, scientific = FALSE))
}
# Convert coordinates to regular decimal notation
combined_df_xy$x <- sapply(df$x, convert_sci_to_decimal)
library(dplyr)
# Add 'PointType' column to locations_industry
locations_industry <- locations_industry %>%
mutate(PointType = "INDUSTRY")
# Add 'PointType' column to bench
locations_bench <- locations_bench %>%
mutate(PointType = "BENCH")
# Combine the data frames by rows (bind_rows)
# Combine the selected columns by rows (bind_rows)
combined_df_lonlat <- bind_rows(select(locations_industry, Lat, Lon, PointType),
select(locations_bench, Lat, Lon, PointType))
# Assuming 'combined_df_lonlat' has columns 'Lat', 'Lon', and 'PointType'
combined_df_xy <- combined_df_lonlat %>%
rename(x = Lat,
y = Lon)
combined_df_xy
# Function to convert long coordinates to a readable format
convert_coordinates <- function(data) {
data$x <- data$x / 1000
data$y <- data$y / 1000
return(data)
}
# Convert coordinates
shortened_data <- convert_coordinates(combined_df_xy)
# Print the shortened data
print(shortened_data)
library(dplyr)
# Add 'PointType' column to locations_industry
locations_industry <- locations_industry %>%
mutate(PointType = "INDUSTRY")
# Add 'PointType' column to bench
locations_bench <- locations_bench %>%
mutate(PointType = "BENCH")
# Combine the data frames by rows (bind_rows)
# Combine the selected columns by rows (bind_rows)
combined_df_lonlat <- bind_rows(select(locations_industry, Lat, Lon, PointType),
select(locations_bench, Lat, Lon, PointType))
# Assuming 'combined_df_lonlat' has columns 'Lat', 'Lon', and 'PointType'
combined_df_xy <- combined_df_lonlat %>%
rename(x = Lat,
y = Lon)
combined_df_xy
# Function to convert long coordinates to a readable format
convert_coordinates <- function(data) {
data$x <- data$x / 100
data$y <- data$y / 100
return(data)
}
# Convert coordinates
shortened_data <- convert_coordinates(combined_df_xy)
# Print the shortened data
print(shortened_data)
View(X)
